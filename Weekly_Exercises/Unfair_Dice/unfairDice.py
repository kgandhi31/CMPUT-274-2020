# ------------------------------------------------------------
# Name : Krish Gandhi
# ID: 1621641
# CMPUT 274, Fall 2020
#
# Weekly Exercise #2: Unfair Dice
# ------------------------------------------------------------

import random


def biased_rolls(prob_list, s, n):
    """ Simulate n rolls of a biased m-sided die and return
    a list containing the results.

    Arguments:
        prob_list: a list of the probabilities of rolling the
                   number on each side of the m-sided die. The list
                   will always have the length m (m >= 2), where m is
                   the number of sides numbered 1 to m. Therefore,
                   for example, the probability stored at index 0 in
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of
            the biased die, in the order they were generated.
    """

    # a list that stores the results of the rolls
    rolls = []

    # a list used to "map" a number range in the interaval [0.0, 1.0) which
    # corresponds to a die face, based on the given probablities.
    # first range is from 0
    map_ranges = [0]

    die_sides = len(prob_list)

    # add ranges to map_ranges where the new_range, the (i + 1)th element, is
    # equal to the cumulative sum of the elements in prob_list from 0 to i.
    for i in range(die_sides):
        new_range = map_ranges[i] + prob_list[i]
        map_ranges.append(new_range)

    random.seed(s)

    # generate n rolls and use map_ranges to give each roll an integer
    # from 1 to die_sides inclusive
    for i in range(n):
        rand_num = random.random()

        # find corresponding face value of rand_num, and append it to rolls
        for j in range(die_sides):
            if (rand_num >= map_ranges[j]) and (rand_num < map_ranges[j + 1]):
                rolls.append(j + 1)

    return rolls


def draw_histogram(m, rolls, width):
    """ Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments:
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output)
    """

    # find the frequency of the most occurring number in rolls
    max_frequency = rolls.count(1)
    for i in range(m):
        if (rolls.count(i + 1) > max_frequency):
            max_frequency = rolls.count(i + 1)

    # print histogram to standard output
    print("Frequency Histogram: {}-sided Die".format(m))
    for i in range(m):
        # calculate the required amount of hashes for a side on the die,
        # and scale it based on the width and the max_frequency
        hashes = round(rolls.count(i + 1) * (width / max_frequency))
        hyphens = width - hashes

        print(i + 1, ".", "#" * hashes, "-" * hyphens, sep="")


if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This is used to test the
    # implementation of the above functions.

    # test cases
    draw_histogram(4, [3, 2, 1, 2, 2, 3, 4, 4, 3, 3], 4)
    print()
    rolls = biased_rolls([1/12, 1/4, 1/3, 1/12, 1/12, 1/6], (2**32)-1, 20)
    print(rolls)
    draw_histogram(6, rolls, 50)
    print()
    rolls = biased_rolls([1/4, 1/6, 1/12, 1/12, 1/4, 1/6], 42, 200)
    draw_histogram(6, rolls, 10)
    print()
    rolls = biased_rolls([1/3, 1/3, 1/3], (2**32)-1, 1000)
    draw_histogram(3, rolls, 10)
